# Cursor Rules for Sitecore Content SDK Go

## Project Overview

This is the **Sitecore Content SDK for Go** - a comprehensive Go SDK for building server-rendered web applications with Sitecore XM Cloud. The project provides core SDK functionality, component renderers using Templ, and integration patterns for Go web frameworks.

## Tech Stack

- **Language**: Go 1.21+
- **Template Engine**: Templ (https://templ.guide)
- **Testing**: Go testing package
- **Build**: `go build`, `templ generate` for templates
- **Linting**: golangci-lint

## Repository Structure

```
xmc-go/
├── content-sdk-go/              # Core SDK package
│   ├── client/                  # Sitecore API clients
│   ├── components/              # Field renderer components (Templ)
│   ├── config/                  # Configuration management
│   ├── handlers/                # HTTP handlers for routing
│   ├── layoutService/           # Layout service integration
│   ├── middleware/              # HTTP middleware
│   ├── models/                  # Field types and data models
│   └── graphql/                 # GraphQL client
└── xmcloud-starter-go/          # Example applications
    └── examples/
        ├── basic-go/            # Basic example
        └── kit-go-product-listing/  # Full featured example
```

## Critical Rules

### Field Rendering

**ALWAYS use SDK component renderers for Sitecore fields**

```go
// ✅ CORRECT - Uses SDK component with editing support
@sdkcomponents.PlainText(ds.TitleRaw, "title", isEditingMode)
@sdkcomponents.Link(item.LinkRaw, "link", isEditingMode, "css-classes")
@sdkcomponents.RichText(field, "content", isEditingMode, "")
@sdkcomponents.Image(field, "image", isEditingMode, "", "", "")

// ❌ WRONG - Manual rendering breaks page editing
{ ds.Title.Value }
<a href={link.GetHref()}>{ link.GetText() }</a>
```

**Why**: SDK components handle Experience Editor chrome markers and editing metadata automatically.

### Strongly Typed Data Patterns

**ALWAYS extract datasource data into strongly-typed structs**

```go
// ✅ CORRECT - Strongly typed with raw data preserved
type LinkListDatasource struct {
    Title    *sdkmodels.TextField
    TitleRaw interface{}         // For SDK component rendering
    Items    []*LinkListItem
}

type LinkListItem struct {
    Link    *sdkmodels.LinkField
    LinkRaw interface{}           // For SDK component rendering
}

// Extract once, use throughout component
if ds := models.ExtractLinkListDatasource(datasource); ds.HasItems() {
    @sdkcomponents.PlainText(ds.TitleRaw, "title", isEditingMode)
    for _, item := range ds.Items {
        @sdkcomponents.Link(item.LinkRaw, "link", isEditingMode, "")
    }
}
```

```go
// ❌ WRONG - Nested type assertions everywhere
if data, ok := datasource["data"].(map[string]interface{}); ok {
    if ds, ok := data["datasource"].(map[string]interface{}); ok {
        if children, ok := ds["children"].(map[string]interface{}); ok {
            if results, ok := children["results"].([]interface{}); ok {
                // This is too complex and error-prone
            }
        }
    }
}
```

### Hybrid Approach Benefits

Store BOTH strongly-typed fields AND raw field data:
- **Typed fields**: For validation, checks, and business logic
- **Raw fields**: For passing to SDK component renderers

```go
type ComponentDatasource struct {
    // Strongly-typed for logic
    Title *sdkmodels.TextField
    Image *sdkmodels.ImageField
    Link  *sdkmodels.LinkField
    
    // Raw data for SDK rendering
    TitleRaw interface{}
    ImageRaw interface{}
    LinkRaw  interface{}
}
```

### Component Variant Pattern

**ALWAYS use the variant pattern for components with multiple visual variations**

```go
// ✅ CORRECT - Single component with variant switching

// Define variant type and constants
type ComponentVariant string

const (
    VariantDefault  ComponentVariant = "Default"
    VariantLogoLeft ComponentVariant = "LogoLeft"
    VariantCentered ComponentVariant = "Centered"
)

// Helper function to extract variant from params
func GetComponentVariant(params map[string]interface{}) ComponentVariant {
    if params == nil {
        return VariantDefault
    }
    
    if variant, ok := params["Variant"].(string); ok {
        switch variant {
        case "LogoLeft":
            return VariantLogoLeft
        case "Centered":
            return VariantCentered
        default:
            return VariantDefault
        }
    }
    
    return VariantDefault
}
```

```templ
// Main component (exported) - switches on variant
templ Component(fields interface{}, params map[string]interface{}) {
    if ds := models.ExtractComponentDatasource(fields); ds != nil {
        if isEditingMode := components.GetEditingMode(params); true {
            switch models.GetComponentVariant(params) {
            case models.VariantLogoLeft:
                @componentLogoLeft(ds, params, isEditingMode)
            case models.VariantCentered:
                @componentCentered(ds, params, isEditingMode)
            default:
                @componentDefault(ds, params, isEditingMode)
            }
        }
    }
}

// Variant sub-components (unexported)
templ componentDefault(ds *models.ComponentDatasource, params map[string]interface{}, isEditingMode bool) {
    // Default variant implementation
}

templ componentLogoLeft(ds *models.ComponentDatasource, params map[string]interface{}, isEditingMode bool) {
    // LogoLeft variant implementation
}
```

```go
// Component registry - register only the main component
r.Register("Component", components.Component)
```

**Why This Pattern**:
- ✅ Single registration in component registry
- ✅ Variant logic centralized in one place  
- ✅ Sitecore controls variant through params
- ✅ Cleaner, more maintainable code
- ✅ All variants share the same strongly-typed datasource

```go
// ❌ WRONG - Separate components for each variant
templ ComponentDefault(fields interface{}, params map[string]interface{})
templ ComponentLogoLeft(fields interface{}, params map[string]interface{})
templ ComponentCentered(fields interface{}, params map[string]interface{})

// Registry becomes cluttered
r.Register("Component", components.ComponentDefault)
r.Register("ComponentDefault", components.ComponentDefault)
r.Register("ComponentLogoLeft", components.ComponentLogoLeft)
r.Register("ComponentCentered", components.ComponentCentered)
```

## Go Best Practices

### Naming Conventions

**Packages**:
- Use lowercase, single words: `models`, `handlers`, `components`
- Match directory names exactly

**Types and Structs**:
- Use PascalCase: `TextField`, `LinkListDatasource`, `ComponentFields`
- Export types that are used across packages

**Functions and Methods**:
- Use PascalCase for exported: `ExtractLinkField`, `GetPage`
- Use camelCase for unexported: `extractLinkListItem`, `parseConfig`
- Prefix boolean functions with `Is`, `Has`, `Can`, `Should`

**Variables**:
- Use camelCase: `isEditingMode`, `datasource`, `fieldData`
- Short names in small scopes: `ds`, `item`, `err`
- Descriptive names in larger scopes

**Constants**:
- Use PascalCase for exported: `DefaultTimeout`, `MaxRetries`
- Use camelCase for unexported: `defaultPort`, `maxConnections`

### Code Organization

```go
// Good import grouping
import (
    // 1. Standard library
    "context"
    "fmt"
    "net/http"
    
    // 2. External dependencies
    "github.com/labstack/echo/v4"
    
    // 3. Internal SDK imports
    sdkcomponents "github.com/content-sdk-go/components"
    sdkmodels "github.com/content-sdk-go/models"
    
    // 4. Local imports
    "github.com/xmcloud-starter-go/examples/kit-go-product-listing/models"
)
```

### Error Handling

```go
// ✅ CORRECT - Handle errors immediately
func GetPage(path string) (*Page, error) {
    data, err := fetchLayoutData(path)
    if err != nil {
        return nil, fmt.Errorf("fetch layout data: %w", err)
    }
    
    page, err := parsePage(data)
    if err != nil {
        return nil, fmt.Errorf("parse page: %w", err)
    }
    
    return page, nil
}

// ❌ WRONG - Ignoring errors
data, _ := fetchLayoutData(path)  // Never do this
```

### Nil Checks

```go
// ✅ CORRECT - Guard clauses at the start
func ProcessField(field interface{}) string {
    if field == nil {
        return ""
    }
    
    fieldMap, ok := field.(map[string]interface{})
    if !ok {
        return ""
    }
    
    // ... processing logic
}
```

## Modern Go Constructs (Go 1.18+)

**ALWAYS use modern Go features and standard library functions** when available.

### Use 'any' instead of 'interface{}' (Go 1.18+)

```go
// ✅ CORRECT - Modern
func ProcessField(field any) string {
    fieldMap, ok := field.(map[string]interface{})
    // ...
}

type ComponentDatasource struct {
    TitleRaw any  // Modern
}

// ❌ WRONG - Legacy
func ProcessField(field interface{}) string { }
type ComponentDatasource struct {
    TitleRaw interface{}  // Legacy
}
```

### Use built-in min/max (Go 1.21+)

```go
// ✅ CORRECT - Built-in functions
height := max(minHeight, calculatedHeight)
width := min(maxWidth, availableWidth)
pageSize := max(1, min(requestedSize, 100))

// ❌ WRONG - Manual conditionals
var height int
if calculatedHeight > minHeight {
    height = calculatedHeight
} else {
    height = minHeight
}
```

### Use slices package (Go 1.21+)

```go
import "slices"

// ✅ CORRECT - slices.Contains
if slices.Contains(validTypes, fieldType) {
    // ...
}

// ❌ WRONG - Manual loop
found := false
for _, t := range validTypes {
    if t == fieldType {
        found = true
        break
    }
}

// ✅ CORRECT - slices.Sort
slices.Sort(items)

// ❌ WRONG - sort.Slice
sort.Slice(items, func(i, j int) bool {
    return items[i] < items[j]
})

// ✅ CORRECT - slices.Clone
newSlice := slices.Clone(originalSlice)

// ❌ WRONG - Manual copy
newSlice := append([]string(nil), originalSlice...)
```

### Use maps package (Go 1.21+)

```go
import "maps"

// ✅ CORRECT - maps.Clone
newMap := maps.Clone(originalMap)

// ❌ WRONG - Manual loop
newMap := make(map[string]string)
for k, v := range originalMap {
    newMap[k] = v
}

// ✅ CORRECT - maps.Copy
maps.Copy(destination, source)

// ✅ CORRECT - maps.Collect from iterator
result := maps.Collect(someIterator())
```

### Range over integers (Go 1.22+)

```go
// ✅ CORRECT - Range over integer
for i := range 10 {
    fmt.Println(i)  // 0 through 9
}

for i := range count {
    items[i] = processItem(i)
}

// ❌ WRONG - Traditional 3-clause loop
for i := 0; i < 10; i++ {
    fmt.Println(i)
}
```

### Simplified loop variables (Go 1.22+)

```go
// ✅ CORRECT - No need for x := x pattern in Go 1.22+
for _, item := range items {
    go func() {
        process(item)  // Safe in Go 1.22+
    }()
}

// ❌ WRONG - Unnecessary in Go 1.22+
for _, item := range items {
    item := item  // Not needed anymore
    go func() {
        process(item)
    }()
}
```

### Use strings.Cut and strings.CutPrefix (Go 1.20+)

```go
// ✅ CORRECT - strings.CutPrefix
if result, found := strings.CutPrefix(path, "/api/"); found {
    return result
}

// ❌ WRONG - HasPrefix + TrimPrefix
if strings.HasPrefix(path, "/api/") {
    return strings.TrimPrefix(path, "/api/")
}

// ✅ CORRECT - strings.Cut
if before, after, found := strings.Cut(header, ":"); found {
    return before, after
}

// ❌ WRONG - strings.Split with length check
parts := strings.Split(header, ":")
if len(parts) == 2 {
    return parts[0], parts[1]
}
```

### Use fmt.Appendf (Go 1.19+)

```go
// ✅ CORRECT - fmt.Appendf
var buf []byte
buf = fmt.Appendf(buf, "Name: %s, Age: %d", name, age)

// ❌ WRONG - []byte(fmt.Sprintf(...))
buf := []byte(fmt.Sprintf("Name: %s, Age: %d", name, age))
```

### Use t.Context() in tests (Go 1.24+)

```go
// ✅ CORRECT - t.Context()
func TestSomething(t *testing.T) {
    ctx := t.Context()  // Automatically canceled when test completes
    result, err := FetchData(ctx)
    // ...
}

// ❌ WRONG - Manual context.WithCancel
func TestSomething(t *testing.T) {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    result, err := FetchData(ctx)
    // ...
}
```

### Use b.Loop() in benchmarks (Go 1.23+)

```go
// ✅ CORRECT - b.Loop()
func BenchmarkProcess(b *testing.B) {
    for b.Loop() {
        Process(data)
    }
}

// ❌ WRONG - for i := range b.N or b.ResetTimer patterns
func BenchmarkProcess(b *testing.B) {
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        Process(data)
    }
}
```

### Use strings.*Seq iterators (Go 1.24+)

```go
// ✅ CORRECT - SplitSeq for iteration
for part := range strings.SplitSeq(text, ",") {
    process(part)
}

// ❌ WRONG - Split with range
for _, part := range strings.Split(text, ",") {
    process(part)
}

// ✅ CORRECT - FieldsSeq
for field := range strings.FieldsSeq(text) {
    process(field)
}

// ❌ WRONG - Fields with range
for _, field := range strings.Fields(text) {
    process(field)
}
```

### Use sync.WaitGroup.Go (Go 1.25+)

```go
// ✅ CORRECT - WaitGroup.Go
var wg sync.WaitGroup
for _, item := range items {
    wg.Go(func() {
        process(item)
    })
}
wg.Wait()

// ❌ WRONG - Manual Add/Done pattern
var wg sync.WaitGroup
for _, item := range items {
    wg.Add(1)
    go func(item Item) {
        defer wg.Done()
        process(item)
    }(item)
}
wg.Wait()
```

### Modernization Command

To modernize existing code automatically:

```bash
# Install modernize tool
go install golang.org/x/tools/gopls/internal/analysis/modernize/cmd/modernize@latest

# Apply all fixes
modernize -fix -test ./...

# Apply specific category (e.g., efaceany)
modernize -category=efaceany -fix -test ./...

# Apply all except specific category
modernize -category=-efaceany -fix -test ./...
```

## Templ Template Best Practices

### Component Structure

```templ
// Component with clear parameters
templ LinkList(fields interface{}, params map[string]interface{}) {
    if datasource := models.ExtractDatasourceField(fields); datasource != nil {
        if ds := models.ExtractLinkListDatasource(datasource); ds.HasItems() {
            <div class="link-list">
                <h3>
                    @sdkcomponents.PlainText(ds.TitleRaw, "title", isEditingMode)
                </h3>
                <ul>
                    for _, item := range ds.Items {
                        @LinkListItem(item, isEditingMode)
                    }
                </ul>
            </div>
        }
    }
}
```

### Template Syntax

- Use `@` prefix for templ function calls: `@ComponentName(params)`
- Use `@templ.Raw()` for HTML strings: `@templ.Raw(htmlString)`
- Use `templ.SafeURL()` for href attributes: `href={ templ.SafeURL(url) }`
- Use `{ }` for Go expressions in templates: `{ item.Value }`
- Use `if`, `for`, `switch` directly (no `@` prefix for control flow)

### Conditional Rendering

```templ
// ✅ CORRECT - Clear conditions
if ds.HasItems() {
    for _, item := range ds.Items {
        if item.Link != nil && !item.Link.IsEmpty() {
            @sdkcomponents.Link(item.LinkRaw, "link", isEditingMode, "")
        }
    }
}

// ❌ WRONG - Nested type assertions in templates
if items, ok := data["items"].([]interface{}); ok {
    // Template should not do type assertions
}
```

## Sitecore SDK Patterns

### Field Types

Use strongly-typed field models from SDK:

```go
import sdkmodels "github.com/content-sdk-go/models"

// Available field types
*sdkmodels.TextField       // Single/Multi-line text
*sdkmodels.RichTextField   // Rich text with HTML
*sdkmodels.LinkField       // General Link
*sdkmodels.ImageField      // Image field
```

### Field Extraction

Create extraction functions for complex structures:

```go
// ExtractComponentDatasource converts generic map to strongly-typed struct
func ExtractComponentDatasource(datasource map[string]interface{}) *ComponentDatasource {
    if datasource == nil {
        return &ComponentDatasource{}
    }
    
    result := &ComponentDatasource{}
    
    // Extract fields
    if field, ok := datasource["field"].(map[string]interface{}); ok {
        titleField := GetFieldByName(field, "title")
        result.Title = sdkmodels.ExtractTextFieldFromMap(titleField)
        result.TitleRaw = titleField  // Store raw for SDK components
    }
    
    return result
}
```

### Component Rendering

```templ
// Component template using SDK renderers
templ MyComponent(fields interface{}, params map[string]interface{}) {
    if ds := models.ExtractMyComponentDatasource(fields); ds != nil {
        <div>
            // Use SDK components for all field rendering
            <h1>
                @sdkcomponents.PlainText(ds.TitleRaw, "title", isEditingMode)
            </h1>
            <div>
                @sdkcomponents.RichText(ds.ContentRaw, "content", isEditingMode, "prose")
            </div>
            <div>
                @sdkcomponents.Image(ds.ImageRaw, "image", isEditingMode, "w-full", "", "")
            </div>
            @sdkcomponents.Link(ds.LinkRaw, "cta", isEditingMode, "btn btn-primary")
        </div>
    }
}
```

## Testing

```go
func TestExtractLinkListDatasource(t *testing.T) {
    // Arrange
    datasource := map[string]interface{}{
        "field": map[string]interface{}{
            "title": map[string]interface{}{
                "jsonValue": map[string]interface{}{
                    "value": "Test Title",
                },
            },
        },
    }
    
    // Act
    result := ExtractLinkListDatasource(datasource)
    
    // Assert
    if result == nil {
        t.Fatal("Expected non-nil result")
    }
    if result.Title == nil {
        t.Error("Expected Title to be set")
    }
    if result.Title.Value != "Test Title" {
        t.Errorf("Expected 'Test Title', got '%s'", result.Title.Value)
    }
}
```

## Performance

- Cache expensive operations (API calls, GraphQL queries)
- Use pointers for large structs
- Avoid unnecessary allocations in hot paths
- Use `sync.Pool` for frequently allocated objects

## Security

- Always validate user input
- Sanitize data at boundaries
- Use parameterized queries for databases
- Never log sensitive information
- Use environment variables for secrets

## Common Patterns

### Handler Pattern

```go
func PageHandler(c echo.Context) error {
    path := c.Param("*")
    
    page, err := layoutService.GetPage(context.Background(), path)
    if err != nil {
        return err
    }
    
    return components.Layout(page).Render(c.Request().Context(), c.Response())
}
```

### Middleware Pattern

```go
func EditingMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
    return func(c echo.Context) error {
        // Check for editing mode
        isEditing := c.QueryParam("sc_mode") == "edit"
        c.Set("isEditingMode", isEditing)
        
        return next(c)
    }
}
```

## Documentation

- Add godoc comments to all exported types and functions
- Use complete sentences starting with the type/function name
- Include examples for complex functionality

```go
// LinkListDatasource represents the strongly-typed structure for LinkList component data.
// It contains both typed fields for validation and raw data for SDK component rendering.
type LinkListDatasource struct {
    Title    *sdkmodels.TextField
    TitleRaw interface{}
    Items    []*LinkListItem
}

// HasItems checks if the datasource has any items.
func (d *LinkListDatasource) HasItems() bool {
    return d != nil && len(d.Items) > 0
}
```

## Anti-Patterns to Avoid

❌ **Don't**: Manually render field values in templates
✅ **Do**: Use SDK component renderers

❌ **Don't**: Use deeply nested type assertions
✅ **Do**: Extract to strongly-typed structs once

❌ **Don't**: Ignore errors
✅ **Do**: Handle every error appropriately

❌ **Don't**: Use `panic` in production code
✅ **Do**: Return errors to callers

❌ **Don't**: Mix business logic in templates
✅ **Do**: Keep templates simple, logic in Go code

