package components

import (
	"fmt"
	"github.com/guitarrich/content-sdk-go/models"
)

// RichText renders a rich text field with chrome markers in editing mode
// Parameters:
//   - fieldData: The raw field data from Sitecore
//   - fieldName: The field name (used for chrome markers)
//   - isEditingMode: Whether we're in editing mode
//   - cssClass: Optional CSS class to apply to the container
templ RichText(fieldData interface{}, fieldName string, isEditingMode bool, cssClass string) {
	if field := models.ExtractRichTextFieldFromMap(fieldData); !field.IsEmpty() {
		if isEditingMode && field.Editable != "" {
			// Use editable HTML with embedded chrome from Sitecore
			@templ.Raw(field.Editable)
		} else if isEditingMode {
			// Manual chrome markers with metadata support
			if field.Metadata != nil {
				@ChromeFieldOpenWithMetadata(fieldName, field.Metadata)
			} else {
				@ChromeFieldOpen(fieldName, "rich-text")
			}
			<div class={ "rich-text content-sdk-rich-text", cssClass } data-field-name={ fieldName }>
				@templ.Raw(field.GetValue().(string))
			</div>
			@ChromeFieldClose()
		} else {
			// Normal mode - no chrome
			<div class={ "rich-text content-sdk-rich-text", cssClass }>
				@templ.Raw(field.Value)
			</div>
		}
	}
}

// Image renders an image field with chrome markers in editing mode
// Parameters:
//   - field: The strongly-typed ImageField from Sitecore
//   - fieldName: The field name (used for chrome markers)
//   - isEditingMode: Whether we're in editing mode
//   - cssClass: Optional CSS class to apply to the image
//   - width: Optional width to override field's width (pass "" to use field's width)
//   - height: Optional height to override field's height (pass "" to use field's height)
//
// Note: In editing mode, field.Metadata must be present or an error will be rendered
templ Image(field *models.ImageField, fieldName string, isEditingMode bool, cssClass string, width string, height string) {
	if err := validateImageFieldForEditing(field, fieldName, isEditingMode); err != nil {
		@FieldValidationError(fieldName, err.Error())
		@templ.Raw(fmt.Sprintf("<!-- Field Validation Error: %v -->", field))
	} else if field != nil && !field.IsEmpty() {
		if isEditingMode {
			// Manual chrome markers with metadata (required in editing mode)
			@ChromeFieldOpenWithMetadata(fieldName, field.Metadata)
			// Determine which width and height to use
			if (width != "" || field.GetWidth() != "") && (height != "" || field.GetHeight() != "") {
				<img
					src={ templ.SafeURL(field.GetSrc()) }
					alt={ field.GetAlt() }
					if width != "" {
						width={ width }
					} else {
						width={ field.GetWidth() }
					}
					if height != "" {
						height={ height }
					} else {
						height={ field.GetHeight() }
					}
					class={ cssClass }
					data-field-name={ fieldName }
				/>
			} else {
				<img
					src={ templ.SafeURL(field.GetSrc()) }
					alt={ field.GetAlt() }
					class={ cssClass }
					data-field-name={ fieldName }
				/>
			}
			@ChromeFieldClose()
		} else {
			// Normal mode - no chrome
			// Determine which width and height to use
			if (width != "" || field.GetWidth() != "") && (height != "" || field.GetHeight() != "") {
				<img
					src={ templ.SafeURL(field.GetSrc()) }
					alt={ field.GetAlt() }
					if width != "" {
						width={ width }
					} else {
						width={ field.GetWidth() }
					}
					if height != "" {
						height={ height }
					} else {
						height={ field.GetHeight() }
					}
					class={ cssClass }
				/>
			} else {
				<img
					src={ templ.SafeURL(field.GetSrc()) }
					alt={ field.GetAlt() }
					class={ cssClass }
				/>
			}
		}
	}
}

// validateImageFieldForEditing validates that an image field has required metadata in editing mode
func validateImageFieldForEditing(field *models.ImageField, fieldName string, isEditingMode bool) error {
	if !isEditingMode {
		return nil
	}
	if field == nil {
		return nil // Empty fields are allowed
	}
	if field.Metadata == nil {
		return fmt.Errorf("field '%s' is missing required metadata in editing mode", fieldName)
	}
	return nil
}

// Link renders a link field with chrome markers in editing mode
// Parameters:
//   - fieldData: The raw field data from Sitecore
//   - fieldName: The field name (used for chrome markers)
//   - isEditingMode: Whether we're in editing mode
//   - cssClass: Optional CSS class to apply to the link
//   - children: Optional child components to render inside the link (if not provided, uses link text)
templ Link(fieldData interface{}, fieldName string, isEditingMode bool, cssClass string, children ...templ.Component) {
	if field := models.ExtractLinkFieldFromMap(fieldData); !field.IsEmpty() {
		if isEditingMode {
			// Manual chrome markers with metadata support
			if field.Metadata != nil {
				@ChromeFieldOpenWithMetadata(fieldName, field.Metadata)
			} else {
				@ChromeFieldOpen(fieldName, "link")
			}
			<a
				href={ templ.SafeURL(field.GetHref()) }
				if field.GetTarget() != "" {
					target={ field.GetTarget() }
				}
				if field.GetTitle() != "" {
					title={ field.GetTitle() }
				}
				class={ field.GetClass(), cssClass }
				data-field-name={ fieldName }
			>
				if len(children) > 0 {
					for _, child := range children {
						@child
					}
				} else if field.GetText() != "" {
					{ field.GetText() }
				}
			</a>
			@ChromeFieldClose()
		} else {
			// Normal mode - no chrome
			<a
				href={ templ.SafeURL(field.GetHref()) }
				if field.GetTarget() != "" {
					target={ field.GetTarget() }
				}
				if field.GetTitle() != "" {
					title={ field.GetTitle() }
				}
				class={ field.GetClass(), cssClass }
			>
				if len(children) > 0 {
					for _, child := range children {
						@child
					}
				} else if field.GetText() != "" {
					{ field.GetText() }
				}
			</a>
		}
	}
}

// PlainText renders a plain text field value without any wrapper tag
// This is useful for inserting text directly into existing HTML or when you don't need a wrapper
// Parameters:
//   - field: The strongly-typed TextField from Sitecore (use models.ExtractTextFieldFromMap to extract)
//   - fieldName: The field name (used for chrome markers)
//   - isEditingMode: Whether we're in editing mode
//
// Note: In editing mode, field.Metadata must be present or an error will be rendered
templ PlainText(field *models.TextField, fieldName string, isEditingMode bool) {
	if err := validateFieldForEditing(field, fieldName, isEditingMode); err != nil {
		@FieldValidationError(fieldName, err.Error())
	} else if field != nil {
		if isEditingMode {
			// Manual chrome markers with span wrapper for editing
			@ChromeFieldOpenWithMetadata(fieldName, field.Metadata)
			<span data-field-name={ fieldName }>{ field.Value }</span>
			@ChromeFieldClose()
		} else {
			// Normal mode - just the text value
			{ field.Value }
		}
	}
}

// validateFieldForEditing validates that a text field has required metadata in editing mode
func validateFieldForEditing(field *models.TextField, fieldName string, isEditingMode bool) error {
	if !isEditingMode {
		return nil
	}
	if field == nil {
		return nil // Empty fields are allowed
	}
	if field.Metadata == nil {
		return fmt.Errorf("field '%s' is missing required metadata in editing mode", fieldName)
	}
	return nil
}

// FieldValidationError renders an error message for field validation failures
templ FieldValidationError(fieldName string, errorMessage string) {
	<div class="field-validation-error border-2 border-red-500 bg-red-50 p-2 rounded text-red-800 text-sm">
		<strong>Field Error ({ fieldName }):</strong> { errorMessage }
	</div>
}

// Text renders a simple text field with chrome markers in editing mode
// Parameters:
//   - fieldData: The raw field data from Sitecore
//   - fieldName: The field name (used for chrome markers)
//   - isEditingMode: Whether we're in editing mode
//   - tag: The HTML tag to use (h1, h2, h3, h4, h5, h6, p, span, div)
//   - cssClass: Optional CSS class to apply to the element
templ Text(fieldData interface{}, fieldName string, isEditingMode bool, tag string, cssClass string) {
	if field := models.ExtractTextFieldFromMap(fieldData); !field.IsEmpty() {
		if isEditingMode && field.Editable != "" {
			// Use editable HTML with embedded chrome from Sitecore
			@templ.Raw(field.Editable)
		} else if isEditingMode {
			// Manual chrome markers with metadata support
			if field.Metadata != nil {
				@ChromeFieldOpenWithMetadata(fieldName, field.Metadata)
			} else {
				@ChromeFieldOpen(fieldName, "text")
			}
			switch tag {
				case "h1":
					<h1 class={ cssClass } data-field-name={ fieldName }>{ field.Value }</h1>
				case "h2":
					<h2 class={ cssClass } data-field-name={ fieldName }>{ field.Value }</h2>
				case "h3":
					<h3 class={ cssClass } data-field-name={ fieldName }>{ field.Value }</h3>
				case "h4":
					<h4 class={ cssClass } data-field-name={ fieldName }>{ field.Value }</h4>
				case "h5":
					<h5 class={ cssClass } data-field-name={ fieldName }>{ field.Value }</h5>
				case "h6":
					<h6 class={ cssClass } data-field-name={ fieldName }>{ field.Value }</h6>
				case "p":
					<p class={ cssClass } data-field-name={ fieldName }>{ field.Value }</p>
				case "div":
					<div class={ cssClass } data-field-name={ fieldName }>{ field.Value }</div>
				case "span":
					<span class={ cssClass } data-field-name={ fieldName }>{ field.Value }</span>
				default:
					<span class={ cssClass } data-field-name={ fieldName }>{ field.Value }</span>
			}
			@ChromeFieldClose()
		} else {
			// Normal mode - no chrome
			switch tag {
				case "h1":
					<h1 class={ cssClass }>{ field.Value }</h1>
				case "h2":
					<h2 class={ cssClass }>{ field.Value }</h2>
				case "h3":
					<h3 class={ cssClass }>{ field.Value }</h3>
				case "h4":
					<h4 class={ cssClass }>{ field.Value }</h4>
				case "h5":
					<h5 class={ cssClass }>{ field.Value }</h5>
				case "h6":
					<h6 class={ cssClass }>{ field.Value }</h6>
				case "p":
					<p class={ cssClass }>{ field.Value }</p>
				case "div":
					<div class={ cssClass }>{ field.Value }</div>
				case "span":
					<span class={ cssClass }>{ field.Value }</span>
				default:
					<span class={ cssClass }>{ field.Value }</span>
			}
		}
	}
}
