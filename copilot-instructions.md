# GitHub Copilot Instructions for Sitecore Content SDK Go

## Project Overview

This is the **Sitecore Content SDK for Go** - a comprehensive Go SDK for building high-performance, server-rendered web applications with Sitecore XM Cloud. The project provides core SDK functionality, component renderers using Templ, and integration patterns for popular Go web frameworks.

### Tech Stack
- **Language**: Go 1.21+
- **Template Engine**: Templ (https://templ.guide)
- **Testing**: Go testing package + testify
- **Build**: `go build`, `templ generate` for templates
- **Linting**: golangci-lint
- **Web Framework**: Echo v4 (primary), adaptable to others

### Core Components
- `content-sdk-go` - Core SDK package with models, components, and handlers
- `xmcloud-starter-go` - Example applications and starter templates

## Repository Structure

```
xmc-go/
├── content-sdk-go/              # Core SDK package
│   ├── client/                  # Sitecore API clients (GraphQL, REST)
│   ├── components/              # Field renderer components (Templ)
│   │   ├── fields.templ         # Text, Link, Image, RichText renderers
│   │   ├── editing.templ        # Experience Editor chrome markers
│   │   └── shared.templ         # Shared utilities
│   ├── config/                  # Configuration management
│   ├── handlers/                # HTTP handlers (catch-all, robots, sitemap)
│   ├── layoutService/           # Layout service integration
│   ├── middleware/              # HTTP middleware (editing, locale, redirects)
│   ├── models/                  # Field types and data models
│   │   ├── fields.go            # Field type definitions
│   │   ├── field_extractors.go # Field extraction utilities
│   │   └── field_helpers.go    # Field helper functions
│   ├── graphql/                 # GraphQL client
│   ├── i18n/                    # Internationalization
│   ├── media/                   # Media URL handling
│   └── seo/                     # SEO utilities (robots, sitemap, error pages)
└── xmcloud-starter-go/          # Example applications
    └── examples/
        ├── basic-go/            # Basic example
        └── kit-go-product-listing/  # Full featured example
            ├── components/      # Application components
            ├── models/          # Application-specific models
            └── handlers/        # Application handlers
```

### Key Directories
- **SDK Sources**: `content-sdk-go/` (import as `github.com/content-sdk-go/...`)
- **Templates**: `*.templ` files generate corresponding `*_templ.go` files
- **Never edit**: `*_templ.go` files (generated by Templ)
- **Examples**: `xmcloud-starter-go/examples/` for reference implementations

## Code Style

### Go Standards

Follow standard Go conventions:
- **gofmt**: All code must be formatted with gofmt
- **golangci-lint**: Must pass all linting checks
- **godoc**: All exported types and functions must have doc comments

### Naming Conventions

**Packages**:
```go
// ✅ GOOD - lowercase, single word, matches directory
package models
package handlers
package components
```

**Types and Structs**:
```go
// ✅ GOOD - PascalCase for exported types
type TextField struct { ... }
type LinkListDatasource struct { ... }
type ComponentFields map[string]interface{}

// ✅ GOOD - camelCase for unexported types
type pageCache struct { ... }
type linkItem struct { ... }
```

**Functions**:
```go
// ✅ GOOD - PascalCase for exported functions
func ExtractLinkField(field interface{}) *LinkField { ... }
func GetPage(ctx context.Context, path string) (*Page, error) { ... }

// ✅ GOOD - camelCase for unexported functions
func extractLinkListItem(itemMap map[string]interface{}) *LinkListItem { ... }
func parseFieldValue(data interface{}) string { ... }

// ✅ GOOD - Boolean functions use Is/Has/Can/Should prefix
func (d *LinkListDatasource) HasItems() bool { ... }
func IsEditingMode(params map[string]interface{}) bool { ... }
```

**Variables**:
```go
// ✅ GOOD - camelCase, descriptive in larger scopes
var isEditingMode bool
var datasource map[string]interface{}

// ✅ GOOD - short names in small scopes
for _, item := range items { ... }
if err != nil { ... }
ds := ExtractDatasource(data)
```

**Constants**:
```go
// ✅ GOOD - PascalCase for exported
const DefaultTimeout = 30 * time.Second
const MaxRetries = 3

// ✅ GOOD - camelCase for unexported
const defaultPort = 8080
const maxConnections = 100
```

### Code Organization

```go
// Import grouping (separated by blank lines)
import (
    // 1. Standard library
    "context"
    "fmt"
    "net/http"
    "time"
    
    // 2. External dependencies
    "github.com/labstack/echo/v4"
    
    // 3. SDK imports (aliased to avoid conflicts)
    sdkcomponents "github.com/content-sdk-go/components"
    sdkmodels "github.com/content-sdk-go/models"
    "github.com/content-sdk-go/layoutService"
    
    // 4. Local project imports
    "github.com/xmcloud-starter-go/examples/kit-go-product-listing/models"
)
```

### Error Handling

```go
// ✅ GOOD - Always handle errors
func GetPage(path string) (*Page, error) {
    data, err := fetchLayoutData(path)
    if err != nil {
        return nil, fmt.Errorf("fetch layout data: %w", err)
    }
    
    page, err := parsePage(data)
    if err != nil {
        return nil, fmt.Errorf("parse page: %w", err)
    }
    
    return page, nil
}

// ❌ BAD - Never ignore errors
data, _ := fetchLayoutData(path)

// ❌ BAD - Don't use panic in production code
if err != nil {
    panic(err)
}
```

## Critical SDK Patterns

### 1. Always Use SDK Field Renderers

**MOST IMPORTANT**: Always use SDK component renderers for Sitecore fields. Never manually render field values in templates.

```templ
// ✅ CORRECT - Uses SDK component with editing support
templ MyComponent(fields interface{}, params map[string]interface{}) {
    if ds := models.ExtractMyDatasource(fields); ds != nil {
        <div>
            <h1>
                @sdkcomponents.PlainText(ds.TitleRaw, "title", isEditingMode)
            </h1>
            <div>
                @sdkcomponents.RichText(ds.ContentRaw, "content", isEditingMode, "prose")
            </div>
            @sdkcomponents.Link(ds.LinkRaw, "cta", isEditingMode, "btn btn-primary")
            @sdkcomponents.Image(ds.ImageRaw, "image", isEditingMode, "w-full", "", "")
        </div>
    }
}

// ❌ WRONG - Manual rendering breaks Experience Editor
templ MyComponent(fields interface{}, params map[string]interface{}) {
    <h1>{ ds.Title.Value }</h1>  // Missing editing chrome
    <a href={ templ.SafeURL(ds.Link.GetHref()) }>{ ds.Link.GetText() }</a>  // Missing editing chrome
}
```

**Why This Matters**:
- SDK components automatically add Experience Editor chrome markers
- Handles both editing and normal mode correctly
- Manages editable metadata and wrapper HTML
- Ensures content authors can edit fields in-page

**Available SDK Components**:
```go
// Text fields
sdkcomponents.PlainText(fieldData, fieldName, isEditingMode)
sdkcomponents.Text(fieldData, fieldName, isEditingMode, tag, cssClass)

// Rich text fields
sdkcomponents.RichText(fieldData, fieldName, isEditingMode, cssClass)

// Link fields
sdkcomponents.Link(fieldData, fieldName, isEditingMode, cssClass, children...)

// Image fields
sdkcomponents.Image(fieldData, fieldName, isEditingMode, cssClass, width, height)
```

### 2. Use Strongly-Typed Data Structures

**Always extract datasource data into strongly-typed structs**. This reduces complexity and improves code quality.

```go
// ✅ CORRECT - Strongly-typed data structure
type LinkListDatasource struct {
    // Strongly-typed fields for logic and validation
    Title *sdkmodels.TextField
    Items []*LinkListItem
    
    // Raw field data for SDK component rendering
    TitleRaw interface{}
}

type LinkListItem struct {
    Link    *sdkmodels.LinkField  // For validation and logic
    LinkRaw interface{}            // For SDK component rendering
}

// Extraction function
func ExtractLinkListDatasource(datasource map[string]interface{}) *LinkListDatasource {
    if datasource == nil {
        return &LinkListDatasource{}
    }
    
    result := &LinkListDatasource{
        Items: make([]*LinkListItem, 0),
    }
    
    // Extract title
    if field, ok := datasource["field"].(map[string]interface{}); ok {
        titleField := GetFieldByName(field, "title")
        result.Title = sdkmodels.ExtractTextFieldFromMap(titleField)
        result.TitleRaw = titleField  // Store raw for SDK components
    }
    
    // Extract items
    if children, ok := datasource["children"].(map[string]interface{}); ok {
        if results, ok := children["results"].([]interface{}); ok {
            for _, item := range results {
                if itemMap, ok := item.(map[string]interface{}); ok {
                    linkItem := extractLinkListItem(itemMap)
                    if linkItem != nil {
                        result.Items = append(result.Items, linkItem)
                    }
                }
            }
        }
    }
    
    return result
}

// Helper methods
func (d *LinkListDatasource) HasItems() bool {
    return d != nil && len(d.Items) > 0
}

func (d *LinkListDatasource) GetTitle() string {
    if d != nil && d.Title != nil {
        return d.Title.Value
    }
    return ""
}
```

**Template Usage**:
```templ
templ LinkList(fields interface{}, params map[string]interface{}) {
    // Extract once, use strongly-typed data throughout
    if ds := models.ExtractLinkListDatasource(datasource); ds.HasItems() {
        <div class="link-list">
            <h3>
                @sdkcomponents.PlainText(ds.TitleRaw, "title", isEditingMode)
            </h3>
            <ul>
                for _, item := range ds.Items {
                    if item.Link != nil && !item.Link.IsEmpty() {
                        <li>
                            @sdkcomponents.Link(item.LinkRaw, "link", isEditingMode, "")
                        </li>
                    }
                }
            </ul>
        </div>
    }
}
```

**Comparison**:
```go
// ❌ BAD - Deeply nested type assertions (5+ levels)
if data, ok := datasource["data"].(map[string]interface{}); ok {
    if ds, ok := data["datasource"].(map[string]interface{}); ok {
        if children, ok := ds["children"].(map[string]interface{}); ok {
            if results, ok := children["results"].([]interface{}); ok {
                for _, item := range results {
                    if itemMap, ok := item.(map[string]interface{}); ok {
                        if fieldData, ok := itemMap["field"].(map[string]interface{}); ok {
                            if link := fieldData["link"]; link != nil {
                                // Finally do something with link
                            }
                        }
                    }
                }
            }
        }
    }
}

// ✅ GOOD - Single extraction, strongly-typed access
ds := models.ExtractLinkListDatasource(datasource)
for _, item := range ds.Items {
    // Work with strongly-typed item.Link
}
```

### 3. Hybrid Approach: Typed + Raw Data

Store BOTH strongly-typed fields AND raw field data in your structs:

**Benefits**:
- **Typed fields**: For validation, checks, iteration, and business logic
- **Raw fields**: For passing to SDK component renderers
- **Best of both worlds**: Type safety + proper rendering

```go
type ComponentDatasource struct {
    // Strongly-typed for validation and logic
    Title       *sdkmodels.TextField
    Description *sdkmodels.TextField
    Image       *sdkmodels.ImageField
    Link        *sdkmodels.LinkField
    
    // Raw data for SDK component rendering
    TitleRaw       interface{}
    DescriptionRaw interface{}
    ImageRaw       interface{}
    LinkRaw        interface{}
}

// In extraction function, populate both
func ExtractComponentDatasource(datasource map[string]interface{}) *ComponentDatasource {
    result := &ComponentDatasource{}
    
    if field, ok := datasource["field"].(map[string]interface{}); ok {
        // Extract title
        titleField := GetFieldByName(field, "title")
        result.Title = sdkmodels.ExtractTextFieldFromMap(titleField)
        result.TitleRaw = titleField  // Store raw for SDK
        
        // Extract image
        imageField := GetFieldByName(field, "image")
        result.Image = sdkmodels.ExtractImageFieldFromMap(imageField)
        result.ImageRaw = imageField  // Store raw for SDK
    }
    
    return result
}

// In template, use typed for logic, raw for rendering
templ Component(fields interface{}, params map[string]interface{}) {
    if ds := models.ExtractComponentDatasource(fields); ds != nil {
        // Use typed field for logic
        if ds.Title != nil && !ds.Title.IsEmpty() {
            <h1>
                // Use raw field for rendering
                @sdkcomponents.PlainText(ds.TitleRaw, "title", isEditingMode)
            </h1>
        }
    }
}
```

## Templ Template Best Practices

### Component Structure

```templ
package components

import (
    sdkcomponents "github.com/content-sdk-go/components"
    "github.com/xmcloud-starter-go/examples/kit-go-product-listing/models"
)

// Component with clear parameter types
templ LinkList(fields interface{}, params map[string]interface{}) {
    // Extract to strongly-typed data immediately
    if datasource := models.ExtractDatasourceField(fields); datasource != nil {
        if isEditingMode := GetEditingMode(params); true {
            if ds := models.ExtractLinkListDatasource(datasource); ds.HasItems() {
                @linkListContent(ds, params, isEditingMode)
            }
        }
    }
}

// Sub-components for better organization
templ linkListContent(ds *models.LinkListDatasource, params map[string]interface{}, isEditingMode bool) {
    <div class="link-list">
        <h3>
            @sdkcomponents.PlainText(ds.TitleRaw, "title", isEditingMode)
        </h3>
        <ul>
            for idx, item := range ds.Items {
                @linkListItem(item, idx, len(ds.Items), isEditingMode)
            }
        </ul>
    </div>
}

templ linkListItem(item *models.LinkListItem, index int, total int, isEditingMode bool) {
    if item.Link != nil && !item.Link.IsEmpty() {
        <li class={ getItemClass(index, total) }>
            @sdkcomponents.Link(item.LinkRaw, "link", isEditingMode, "link-class")
        </li>
    }
}

// Helper functions in Go
func getItemClass(index int, total int) string {
    className := fmt.Sprintf("item-%d", index)
    if (index + 1) % 2 == 0 {
        className += " even"
    } else {
        className += " odd"
    }
    if index == 0 {
        className += " first"
    }
    if index == total - 1 {
        className += " last"
    }
    return className
}
```

### Templ Syntax Reference

```templ
// Component calls use @ prefix
@ComponentName(param1, param2)

// SDK component rendering
@sdkcomponents.PlainText(fieldData, "fieldName", isEditingMode)

// Raw HTML rendering
@templ.Raw(htmlString)

// URL sanitization
href={ templ.SafeURL(url) }

// Go expressions in attributes/content
{ variableName }
{ structField.Value }
{ function(param) }

// Control flow (no @ prefix)
if condition {
    // content
}

for index, item := range items {
    // content
}

switch value {
    case "option1":
        // content
    case "option2":
        // content
    default:
        // content
}

// CSS classes (space-separated in braces)
class={ "base-class", conditionalClass, "another-class" }
class={ getClassName() }

// Multiple attributes
<div
    class={ "my-class" }
    id={ elementId }
    data-field={ fieldName }
>
```

### Template Best Practices

```templ
// ✅ GOOD - Clear, single-purpose components
templ HeaderPrimaryLinks(ds *models.LinkListDatasource, isEditingMode bool) {
    if ds.HasItems() {
        <ul class="flex flex-col gap-4">
            for _, item := range ds.Items {
                <li>
                    @sdkcomponents.Link(item.LinkRaw, "link", isEditingMode, "")
                </li>
            }
        </ul>
    }
}

// ✅ GOOD - Early returns for invalid data
templ Component(fields interface{}, params map[string]interface{}) {
    if datasource := models.ExtractDatasourceField(fields); datasource != nil {
        if ds := models.ExtractComponentDatasource(datasource); ds != nil {
            @componentContent(ds, params)
        }
    }
}

// ❌ BAD - Complex logic in templates
templ Component(fields interface{}, params map[string]interface{}) {
    if data, ok := fields.(map[string]interface{}); ok {
        if value := calculateComplexValue(data); value > threshold {
            // Move this logic to Go code
        }
    }
}

// ✅ GOOD - Logic in Go, simple rendering in template
func (ds *ComponentDatasource) ShouldDisplayCTA() bool {
    return ds.Link != nil && !ds.Link.IsEmpty() && ds.CTAText != ""
}

templ Component(ds *models.ComponentDatasource, isEditingMode bool) {
    if ds.ShouldDisplayCTA() {
        @sdkcomponents.Link(ds.LinkRaw, "cta", isEditingMode, "btn")
    }
}
```

## Sitecore SDK Field Types

### Available Field Types

```go
import sdkmodels "github.com/content-sdk-go/models"

// Text field (Single-Line, Multi-Line)
type TextField struct {
    Value    string
    Editable string  // Experience Editor metadata
}

// Rich text field (HTML content)
type RichTextField struct {
    Value    string
    Editable string
}

// Image field
type ImageField struct {
    Src      string
    Alt      string
    Width    string
    Height   string
    Editable string
    Value    *ImageFieldValue  // Nested structure
}

// Link field (General Link)
type LinkField struct {
    Href     string
    Text     string
    Target   string
    Title    string
    Class    string
    Editable string
    Value    *LinkFieldValue  // Nested structure
}

// Field interface (all fields implement)
type Field interface {
    GetValue() interface{}
    GetEditable() string
    IsEmpty() bool
}
```

### Field Helper Functions

```go
// Extract typed fields from raw data
func GetTextField(fields interface{}, fieldName string) *TextField
func GetRichTextField(fields interface{}, fieldName string) *RichTextField
func GetImageField(fields interface{}, fieldName string) *ImageField
func GetLinkField(fields interface{}, fieldName string) *LinkField

// Extract by name
func GetFieldByName(fields interface{}, name string) interface{}

// Check if field is empty
func IsFieldEmpty(fieldData interface{}) bool
func FieldHasValue(fieldData interface{}) bool

// Direct extractors
func ExtractTextFieldFromMap(fieldData interface{}) *TextField
func ExtractRichTextFieldFromMap(fieldData interface{}) *RichTextField
func ExtractImageFieldFromMap(fieldData interface{}) *ImageField
func ExtractLinkFieldFromMap(fieldData interface{}) *LinkField
```

### Field Usage Pattern

```go
// In your model extraction function
func ExtractComponentDatasource(datasource map[string]interface{}) *ComponentDatasource {
    result := &ComponentDatasource{}
    
    if field, ok := datasource["field"].(map[string]interface{}); ok {
        // Extract each field
        titleField := GetFieldByName(field, "title")
        result.Title = sdkmodels.ExtractTextFieldFromMap(titleField)
        result.TitleRaw = titleField
        
        contentField := GetFieldByName(field, "content")
        result.Content = sdkmodels.ExtractRichTextFieldFromMap(contentField)
        result.ContentRaw = contentField
        
        imageField := GetFieldByName(field, "image")
        result.Image = sdkmodels.ExtractImageFieldFromMap(imageField)
        result.ImageRaw = imageField
        
        linkField := GetFieldByName(field, "link")
        result.Link = sdkmodels.ExtractLinkFieldFromMap(linkField)
        result.LinkRaw = linkField
    }
    
    return result
}
```

### Component Variant Pattern

**ALWAYS use the variant pattern for components with multiple visual variations**

Components in Sitecore often have multiple visual variants (e.g., "Default", "LogoLeft", "Centered"). Instead of creating separate component functions for each variant, use a single main component that switches on the variant.

#### Variant Model

```go
// Define variant type and constants
type ComponentVariant string

const (
    VariantDefault  ComponentVariant = "Default"
    VariantLogoLeft ComponentVariant = "LogoLeft"
    VariantCentered ComponentVariant = "Centered"
)

// GetComponentVariant extracts the variant from params
func GetComponentVariant(params map[string]interface{}) ComponentVariant {
    if params == nil {
        return VariantDefault
    }
    
    if variant, ok := params["Variant"].(string); ok {
        switch variant {
        case "LogoLeft":
            return VariantLogoLeft
        case "Centered":
            return VariantCentered
        default:
            return VariantDefault
        }
    }
    
    return VariantDefault
}
```

#### Main Component Template

```templ
// Main component (exported, PascalCase) - switches on variant
templ Component(fields interface{}, params map[string]interface{}) {
    if ds := models.ExtractComponentDatasource(fields); ds != nil {
        if isEditingMode := components.GetEditingMode(params); true {
            switch models.GetComponentVariant(params) {
            case models.VariantLogoLeft:
                @componentLogoLeft(ds, params, isEditingMode)
            case models.VariantCentered:
                @componentCentered(ds, params, isEditingMode)
            default:
                @componentDefault(ds, params, isEditingMode)
            }
        }
    }
}

// Variant sub-components (unexported, camelCase)
templ componentDefault(ds *models.ComponentDatasource, params map[string]interface{}, isEditingMode bool) {
    <section class={ "component-default", models.GetStyleParam(params, "styles") }>
        if ds.HasTitle() {
            <h1>
                @sdkcomponents.PlainText(ds.TitleRaw, "Title", isEditingMode)
            </h1>
        }
        // Default variant implementation
    </section>
}

templ componentLogoLeft(ds *models.ComponentDatasource, params map[string]interface{}, isEditingMode bool) {
    <section class={ "component-logo-left", models.GetStyleParam(params, "styles") }>
        // LogoLeft variant implementation
    </section>
}

templ componentCentered(ds *models.ComponentDatasource, params map[string]interface{}, isEditingMode bool) {
    <section class={ "component-centered", models.GetStyleParam(params, "styles") }>
        // Centered variant implementation
    </section>
}
```

#### Component Registry

```go
// Component registry - register ONLY the main component
func (r *ComponentRegistry) registerComponents() {
    // ✅ CORRECT - Single registration
    r.Register("Component", components.Component)
    
    // ❌ WRONG - Don't register individual variants
    // r.Register("Component", components.ComponentDefault)
    // r.Register("ComponentDefault", components.ComponentDefault)
    // r.Register("ComponentLogoLeft", components.ComponentLogoLeft)
    // r.Register("ComponentCentered", components.ComponentCentered)
}
```

#### Benefits of Variant Pattern

- ✅ **Single registration**: Only one entry in component registry
- ✅ **Centralized logic**: Variant switching in one place
- ✅ **Sitecore-driven**: Variant controlled through Sitecore parameters
- ✅ **Shared datasource**: All variants use the same strongly-typed datasource
- ✅ **Maintainable**: Changes to variant logic happen in one place
- ✅ **Clean code**: No duplication, clear structure

#### Complete Example: Footer with Variants

```go
// models/footer.go
type FooterDatasource struct {
    Title    *sdkmodels.TextField
    TitleRaw interface{}
    // ... other fields
}

type FooterVariant string

const (
    FooterVariantDefault  FooterVariant = "Default"
    FooterVariantLogoLeft FooterVariant = "LogoLeft"
    FooterVariantLogoRight FooterVariant = "LogoRight"
)

func GetFooterVariant(params map[string]interface{}) FooterVariant {
    if variant, ok := params["Variant"].(string); ok {
        switch variant {
        case "LogoLeft":
            return FooterVariantLogoLeft
        case "LogoRight":
            return FooterVariantLogoRight
        default:
            return FooterVariantDefault
        }
    }
    return FooterVariantDefault
}

func ExtractFooterDatasource(fields interface{}) *FooterDatasource {
    // Extract fields
}
```

```templ
// components/footer.templ
templ Footer(fields interface{}, params map[string]interface{}) {
    if ds := models.ExtractFooterDatasource(fields); ds != nil {
        if isEditingMode := components.GetEditingMode(params); true {
            switch models.GetFooterVariant(params) {
            case models.FooterVariantLogoLeft:
                @footerLogoLeft(ds, params, isEditingMode)
            case models.FooterVariantLogoRight:
                @footerLogoRight(ds, params, isEditingMode)
            default:
                @footerDefault(ds, params, isEditingMode)
            }
        }
    }
}

templ footerDefault(ds *models.FooterDatasource, params map[string]interface{}, isEditingMode bool) {
    <footer class="footer-default">
        @sdkcomponents.PlainText(ds.TitleRaw, "Title", isEditingMode)
    </footer>
}

templ footerLogoLeft(ds *models.FooterDatasource, params map[string]interface{}, isEditingMode bool) {
    <footer class="footer-logo-left">
        // Logo left variant
    </footer>
}
```

## Handler and Middleware Patterns

### HTTP Handler Pattern

```go
func PageHandler(layoutService *layoutservice.LayoutService) echo.HandlerFunc {
    return func(c echo.Context) error {
        ctx := c.Request().Context()
        path := c.Param("*")
        
        // Get page data from Layout Service
        page, err := layoutService.GetPage(ctx, path)
        if err != nil {
            return err
        }
        
        // Set editing mode
        isEditing := c.QueryParam("sc_mode") == "edit"
        c.Set("isEditingMode", isEditing)
        
        // Render with Templ component
        return components.Layout(page).Render(ctx, c.Response())
    }
}
```

### Middleware Pattern

```go
// Editing mode middleware
func EditingMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
    return func(c echo.Context) error {
        isEditing := c.QueryParam("sc_mode") == "edit" ||
                     c.QueryParam("sc_mode") == "preview"
        
        c.Set("isEditingMode", isEditing)
        
        if isEditing {
            // Add editing-specific headers
            c.Response().Header().Set("Cache-Control", "no-store")
        }
        
        return next(c)
    }
}

// Locale middleware
func LocaleMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
    return func(c echo.Context) error {
        locale := c.QueryParam("sc_lang")
        if locale == "" {
            locale = "en"  // default
        }
        
        c.Set("locale", locale)
        
        return next(c)
    }
}
```

## Testing

### Unit Tests

```go
func TestExtractLinkListDatasource(t *testing.T) {
    tests := []struct {
        name     string
        input    map[string]interface{}
        wantNil  bool
        wantLen  int
    }{
        {
            name:    "nil datasource",
            input:   nil,
            wantNil: false,  // Returns empty struct, not nil
            wantLen: 0,
        },
        {
            name: "valid datasource with items",
            input: map[string]interface{}{
                "field": map[string]interface{}{
                    "title": map[string]interface{}{
                        "jsonValue": map[string]interface{}{
                            "value": "Test Title",
                        },
                    },
                },
                "children": map[string]interface{}{
                    "results": []interface{}{
                        map[string]interface{}{
                            "field": map[string]interface{}{
                                "link": map[string]interface{}{
                                    "jsonValue": map[string]interface{}{
                                        "value": map[string]interface{}{
                                            "href": "/test",
                                            "text": "Test Link",
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            },
            wantNil: false,
            wantLen: 1,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := ExtractLinkListDatasource(tt.input)
            
            if tt.wantNil && result != nil {
                t.Errorf("Expected nil result, got %v", result)
            }
            
            if !tt.wantNil && result == nil {
                t.Fatal("Expected non-nil result")
            }
            
            if len(result.Items) != tt.wantLen {
                t.Errorf("Expected %d items, got %d", tt.wantLen, len(result.Items))
            }
        })
    }
}
```

### Table-Driven Tests

```go
func TestLinkField_GetHref(t *testing.T) {
    tests := []struct {
        name  string
        field *LinkField
        want  string
    }{
        {
            name:  "direct href",
            field: &LinkField{Href: "/test"},
            want:  "/test",
        },
        {
            name: "nested value href",
            field: &LinkField{
                Value: &LinkFieldValue{Href: "/nested"},
            },
            want: "/nested",
        },
        {
            name:  "empty field",
            field: &LinkField{},
            want:  "",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := tt.field.GetHref()
            if got != tt.want {
                t.Errorf("GetHref() = %v, want %v", got, tt.want)
            }
        })
    }
}
```

## Performance Best Practices

### Efficient Data Structures

```go
// ✅ GOOD - Pre-allocate slices when size is known
items := make([]*LinkListItem, 0, len(results))

// ✅ GOOD - Use pointers for large structs
func ExtractLinkListDatasource(datasource map[string]interface{}) *LinkListDatasource

// ✅ GOOD - Reuse buffers
var buf bytes.Buffer
buf.Reset()
```

### Caching

```go
// Cache expensive operations
type PageCache struct {
    mu    sync.RWMutex
    cache map[string]*Page
}

func (c *PageCache) Get(path string) (*Page, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    page, found := c.cache[path]
    return page, found
}

func (c *PageCache) Set(path string, page *Page) {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    c.cache[path] = page
}
```

## Security Best Practices

### Input Validation

```go
// Always validate user input
func GetPageHandler(c echo.Context) error {
    path := c.Param("*")
    
    // Validate path
    if strings.Contains(path, "..") {
        return echo.NewHTTPError(http.StatusBadRequest, "Invalid path")
    }
    
    // Sanitize
    path = filepath.Clean(path)
    
    // ... rest of handler
}
```

### Environment Variables

```go
// ✅ GOOD - Use environment variables for secrets
apiKey := os.Getenv("SITECORE_API_KEY")
if apiKey == "" {
    return fmt.Errorf("SITECORE_API_KEY not set")
}

// ❌ BAD - Never hardcode secrets
const apiKey = "abc123-hardcoded-key"
```

## Documentation

### Godoc Comments

```go
// LinkListDatasource represents the strongly-typed structure for LinkList component data.
// It contains both typed fields for validation/logic and raw data for SDK component rendering.
type LinkListDatasource struct {
    // Title is the typed text field for the list title
    Title *sdkmodels.TextField
    
    // TitleRaw is the raw field data for SDK component rendering
    TitleRaw interface{}
    
    // Items contains all link items in the list
    Items []*LinkListItem
}

// HasItems checks if the datasource has any items.
// Returns true if Items slice is not empty.
func (d *LinkListDatasource) HasItems() bool {
    return d != nil && len(d.Items) > 0
}

// ExtractLinkListDatasource converts a generic datasource map into a strongly-typed LinkListDatasource.
// It handles both direct datasource structures and nested data.datasource patterns.
//
// Parameters:
//   - datasource: The raw datasource map from Sitecore Layout Service
//
// Returns:
//   - *LinkListDatasource: A strongly-typed datasource with extracted fields
func ExtractLinkListDatasource(datasource map[string]interface{}) *LinkListDatasource {
    // ... implementation
}
```

## Common Anti-Patterns to Avoid

### ❌ Manual Field Rendering
```templ
// BAD - Breaks Experience Editor
<h1>{ ds.Title.Value }</h1>
<a href={ templ.SafeURL(link.GetHref()) }>{ link.GetText() }</a>
```

### ✅ Use SDK Components
```templ
// GOOD - Works in Experience Editor
@sdkcomponents.PlainText(ds.TitleRaw, "title", isEditingMode)
@sdkcomponents.Link(item.LinkRaw, "link", isEditingMode, "")
```

### ❌ Nested Type Assertions
```go
// BAD - Complex, error-prone, hard to maintain
if data, ok := datasource["data"].(map[string]interface{}); ok {
    if ds, ok := data["datasource"].(map[string]interface{}); ok {
        if children, ok := ds["children"].(map[string]interface{}); ok {
            // ... more nesting
        }
    }
}
```

### ✅ Strongly-Typed Extraction
```go
// GOOD - Extract once, use strongly-typed data
ds := models.ExtractLinkListDatasource(datasource)
for _, item := range ds.Items {
    // Work with item.Link
}
```

### ❌ Ignoring Errors
```go
// BAD - Never ignore errors
data, _ := fetchData()
```

### ✅ Handle All Errors
```go
// GOOD - Always handle errors
data, err := fetchData()
if err != nil {
    return fmt.Errorf("fetch data: %w", err)
}
```

### ❌ Panic in Production
```go
// BAD - Don't use panic
if err != nil {
    panic(err)
}
```

### ✅ Return Errors
```go
// GOOD - Return errors to callers
if err != nil {
    return nil, fmt.Errorf("operation failed: %w", err)
}
```

## Summary

### Key Principles

1. **Always use SDK field renderers** - Never manually render field values
2. **Extract to strongly-typed structs** - Reduce complexity and improve maintainability
3. **Store both typed and raw data** - Best of both worlds for validation and rendering
4. **Handle all errors** - Never ignore errors or use panic
5. **Follow Go conventions** - gofmt, golangci-lint, godoc
6. **Write testable code** - Unit tests for extraction functions
7. **Document exported APIs** - Godoc comments for all public types and functions

### Common Workflow

1. **Define strongly-typed struct** with both typed and raw fields
2. **Create extraction function** that populates the struct
3. **Add helper methods** (HasItems, IsEmpty, etc.)
4. **Use in templates** with SDK component renderers
5. **Write tests** for extraction logic
6. **Document** with godoc comments

